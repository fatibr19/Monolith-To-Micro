/*
 * generated by Xtext 2.37.0
 */
package com.ensias.dsl.serializer;

import com.ensias.dsl.microserviceDSL.ActuatorConfig;
import com.ensias.dsl.microserviceDSL.ApplicationConfig;
import com.ensias.dsl.microserviceDSL.ConfigServer;
import com.ensias.dsl.microserviceDSL.DatabaseConfig;
import com.ensias.dsl.microserviceDSL.Discovery;
import com.ensias.dsl.microserviceDSL.Gateway;
import com.ensias.dsl.microserviceDSL.MicroserviceDSLPackage;
import com.ensias.dsl.microserviceDSL.Model;
import com.ensias.dsl.microserviceDSL.RouteConfig;
import com.ensias.dsl.microserviceDSL.ServerConfig;
import com.ensias.dsl.microserviceDSL.Service;
import com.ensias.dsl.services.MicroserviceDSLGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MicroserviceDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MicroserviceDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MicroserviceDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MicroserviceDSLPackage.ACTUATOR_CONFIG:
				sequence_ActuatorConfig(context, (ActuatorConfig) semanticObject); 
				return; 
			case MicroserviceDSLPackage.APPLICATION_CONFIG:
				sequence_ApplicationConfig(context, (ApplicationConfig) semanticObject); 
				return; 
			case MicroserviceDSLPackage.CONFIG_SERVER:
				sequence_ConfigServer(context, (ConfigServer) semanticObject); 
				return; 
			case MicroserviceDSLPackage.DATABASE_CONFIG:
				sequence_DatabaseConfig(context, (DatabaseConfig) semanticObject); 
				return; 
			case MicroserviceDSLPackage.DISCOVERY:
				sequence_Discovery(context, (Discovery) semanticObject); 
				return; 
			case MicroserviceDSLPackage.GATEWAY:
				sequence_Gateway(context, (Gateway) semanticObject); 
				return; 
			case MicroserviceDSLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MicroserviceDSLPackage.ROUTE_CONFIG:
				sequence_RouteConfig(context, (RouteConfig) semanticObject); 
				return; 
			case MicroserviceDSLPackage.SERVER_CONFIG:
				sequence_ServerConfig(context, (ServerConfig) semanticObject); 
				return; 
			case MicroserviceDSLPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ServiceConfigEntry returns ActuatorConfig
	 *     ActuatorConfig returns ActuatorConfig
	 *
	 * Constraint:
	 *     (
	 *         healthcheckPath=STRING | 
	 *         (healthcheckPath=STRING (metricsEnabled='true' | metricsEnabled='false') (infoEnabled='true' | infoEnabled='false')?) | 
	 *         (healthcheckPath=STRING (infoEnabled='true' | infoEnabled='false')?)
	 *     )?
	 * </pre>
	 */
	protected void sequence_ActuatorConfig(ISerializationContext context, ActuatorConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ServiceConfigEntry returns ApplicationConfig
	 *     ApplicationConfig returns ApplicationConfig
	 *
	 * Constraint:
	 *     ((appName=STRING? profile=STRING loggingLevel=LogLevel) | (appName=STRING? loggingLevel=LogLevel) | loggingLevel=LogLevel)?
	 * </pre>
	 */
	protected void sequence_ApplicationConfig(ISerializationContext context, ApplicationConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConfigServer returns ConfigServer
	 *
	 * Constraint:
	 *     (name=ID port=INT gitUri=STRING gitBranch=STRING? customDeps+=Dependency*)
	 * </pre>
	 */
	protected void sequence_ConfigServer(ISerializationContext context, ConfigServer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ServiceConfigEntry returns DatabaseConfig
	 *     DatabaseConfig returns DatabaseConfig
	 *
	 * Constraint:
	 *     (dbUrl=STRING dbUsername=STRING dbPassword=STRING driver=DatabaseDriver ddl=DdlType?)
	 * </pre>
	 */
	protected void sequence_DatabaseConfig(ISerializationContext context, DatabaseConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Discovery returns Discovery
	 *
	 * Constraint:
	 *     (name=ID port=INT defaultZone=STRING? customDeps+=Dependency*)
	 * </pre>
	 */
	protected void sequence_Discovery(ISerializationContext context, Discovery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Gateway returns Gateway
	 *
	 * Constraint:
	 *     (name=ID port=INT routes+=RouteConfig* customDeps+=Dependency*)
	 * </pre>
	 */
	protected void sequence_Gateway(ISerializationContext context, Gateway semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         groupName=QualifiedName 
	 *         version=STRING 
	 *         description=STRING 
	 *         discovery=Discovery 
	 *         configServer=ConfigServer 
	 *         services+=Service* 
	 *         gateway=Gateway
	 *     )
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RouteConfig returns RouteConfig
	 *
	 * Constraint:
	 *     (path=STRING service=[Service|ID])
	 * </pre>
	 */
	protected void sequence_RouteConfig(ISerializationContext context, RouteConfig semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MicroserviceDSLPackage.Literals.ROUTE_CONFIG__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MicroserviceDSLPackage.Literals.ROUTE_CONFIG__PATH));
			if (transientValues.isValueTransient(semanticObject, MicroserviceDSLPackage.Literals.ROUTE_CONFIG__SERVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MicroserviceDSLPackage.Literals.ROUTE_CONFIG__SERVICE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRouteConfigAccess().getPathSTRINGTerminalRuleCall_3_0(), semanticObject.getPath());
		feeder.accept(grammarAccess.getRouteConfigAccess().getServiceServiceIDTerminalRuleCall_5_0_1(), semanticObject.eGet(MicroserviceDSLPackage.Literals.ROUTE_CONFIG__SERVICE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ServiceConfigEntry returns ServerConfig
	 *     ServerConfig returns ServerConfig
	 *
	 * Constraint:
	 *     (port=INT contextPath=STRING?)
	 * </pre>
	 */
	protected void sequence_ServerConfig(ISerializationContext context, ServerConfig semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (name=ID dependencies+=Dependency* configuration+=ServiceConfigEntry*)
	 * </pre>
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
